---
title: "Chapter 6 Functions"
author: "Yang Hu"
format: 
    html:
      self-contained: true
      embed-resources: true

number-sections: false
code-annotations: hover
    
toc: true
toc-title: "Contents"
toc-location: "left"
toc-depth: 4

execute: 
  freeze: auto
  warning: true
---


## Introduction

If you’re reading this book, you’ve probably already created many R functions and know how to use them to reduce duplication in your code. In this chapter, you’ll learn how **to turn that informal, working knowledge into more rigorous, theoretical understanding**. 

And while you’ll see some interesting tricks and techniques along the way, keep in mind that **what you’ll learn here will be important for understanding the more advanced topics discussed later in the book.**


### Quiz

1. What are the three components of a function?

The three components of a function are its **body**, **arguments**, and **environment**.


2. What does the following code return?

```{r}
x <- 10

f1 <- function(x) {
  
  function() {
    x + 10
  }
}

f1(1)()

# Try again:
f1(x = 10)()
```

3. How would you usually write this code?

```{r}
`+`(1, `*`(2, 3))

2 * 3 + 1
```

4. How could you make this call easier to read?

```{r}
mean(, TRUE, x = c(1:10, NA))

# Arguments' order is flexible:

mean(x = c(1:10, NA), na.rm = TRUE, )
```


5. Does the following code throw an error when executed? Why or why not?

```{r}
f2 <- function(a, b) {
  a * 10
}


f2(10, stop("This is an error!"))

f2(10, print("Yo!"))
```

No, it does not throw an error because the second argument is never used so it’s never evaluated.


6. What is an infix function? How do you write it? What’s a replacement function? How do you write it?

7. How do you ensure that cleanup action occurs regardless of how a function exits?



## Function fundamentals

To understand functions in R you need to internalise two important ideas:

- Functions can be broken down into three components: **arguments**, **body**, and **environment**.
There are exceptions to every rule, and in this case, there is a small selection of “primitive” base functions that are implemented purely in C.

- Functions are objects, just as vectors are objects.



### Function components

A function has three parts:

- The `formals()`, the list of arguments that control how you call the function.

- The `body()`, the code inside the function.

- The `environment()`, the data structure that determines how the function finds the values associated with the names.

While the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where you defined the function. The function environment always exists, but it is only printed when the function isn’t defined in the global environment.

```{r}
f02 <- function(x, y) {
  # A comment
  
  x + y
}


formals(f02)

body(f02)

environment(f02)
```

I’ll draw functions as in the following diagram. The black dot on the left is the environment. The two blocks to the right are the function arguments. I won’t draw the body, because it’s usually large, and doesn’t help you understand the shape of the function.

![](pic/components.png){fig-align=center width=65%}


Like all objects in R, functions can also possess any number of additional `attributes()`. One attribute used by base R is `srcref`, short for **source reference**. It points to the source code used to create the function. The `srcref` is used for printing because, unlike `body()`, it contains code comments and other formatting.

```{r}
attr(updatefi::get_econ_fi, "srcref")
```

### Primitive functions

There is one exception to the rule that a function has three components. Primitive functions, like `sum()` and `[`, call C code directly.

```{r}
sum
```

They have either type `builtin` or type `special`.

```{r}
typeof(sum)

typeof(`[`)

# typeof(get_econ_fi)
```


These functions exist primarily in C, not R, so their `formals()`, `body()`, and `environment()` are all `NULL`:

```{r}
formals(sum)

body(sum)

environment(sum)
```

Primitive functions are only found in the base package. While they have certain performance advantages, this benefit comes at a price: they are harder to write. For this reason, R-core generally avoids creating them unless there is no other option.



### First-class functions

It’s very important to understand that **R functions are objects in their own right**, a language property often called “first-class functions”.

Unlike in many other languages, there is no special syntax for defining and naming a function: you simply create a function object (with function) and bind it to a name with `<-`:

```{r}
f01 <- function(x) {
  sin(1 / x ^ 2)
}
```

![](pic/first-class.png){fig-align=center width=65%}

While you almost always create a function and then bind it to a name, the binding step is not compulsory. If you choose not to give a function a name, you get an **anonymous function**. This is useful when it’s not worth the effort to figure out a name:

```{r}
lapply(mtcars, function(x) length(unique(x)))

# \(x) is supported in lapply:
lapply(mtcars, \(x) length(unique(x)))

# Or the purrr style:
purrr::map(mtcars, \(x) length(unique(x)))
```

```{r}
Filter(function(x) !is.numeric(x), mtcars)

# Equivalent to:
dplyr::select(mtcars, !where(is.numeric))
```

```{r}
integrate(function(x) sin(x) ^ 2, 0, pi)
```

A final option is to **put functions in a list**:

```{r}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$half(2)
```

In R, you’ll often see functions called **closures**. This name reflects the fact that R functions capture, or enclose, their environments, which you’ll learn more about in Section 7.4.2.

```{r}
typeof(updatefi::get_econ_fi)
```


### Invoking a function

You normally call a function by placing its arguments, wrapped in parentheses, after its name: `mean(1:10, na.rm = TRUE)`. But what happens if you have the arguments already in a data structure?

You can instead use do.call(): it has two arguments. The function to call, and a list containing the function arguments:
```{r}
mean(1:10, na.rm = TRUE)

do.call(mean, list(1:10, na.rm = TRUE))

# or:

args <- list(1:10, na.rm = TRUE)

do.call(mean, args)
```

### 6.2.5 Exercises

1. Given a name, like `"mean"`, `match.fun()` lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?

**In R there is no one-to-one mapping between functions and names. A name always points to a single object, but an object may have zero, one or many names.**

Let’s look at an example:

```{r}
function(x) sd(x) / mean(x)
#> function(x) sd(x) / mean(x)

f1 <- function(x) (x - min(x)) / (max(x) - min(x))
f2 <- f1
f3 <- f1


# They are one object with different names:
purrr::map(list(f1, f2, f3), \(x){lobstr::obj_addr(x)})
```

While the function in the first line is not bound to a name multiple names (`f1`, `f2` and `f3`) point to the second function. So, the main point is that the relation between name and object is only clearly defined in one direction.

Besides that, there are obviously ways to search for function names. However, to be sure to find the right one(s), you should not only compare the code (body) but also the arguments (formals) and the creation environment. As `formals()`, `body()` and `environment()` all return `NULL` for primitive functions, the easiest way to check if two functions are exactly equal is just to use `identical()`.

```{r}
identical(f1, f2)

identical(updatefi::get_econ_fi, updatefi::get_econ_fi)

identical(updatefi::get_econ_fi, updatefi::update_fi)
```

2. It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{r}
function(x) 3()

(function(x) 3)()
```

The second approach is correct.

The anonymous function `function(x) 3` is surrounded by a pair of parentheses before it is called by `()`. These extra parentheses separate the function call from the anonymous function’s body. Without them a function with the invalid body `3()` is returned, which throws an error when we call it. This is easier to see if we name the function:

```{r}
f <- function(x) 3()
f

# f()
```


3. **A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}.** Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

The use of anonymous functions allows concise and elegant code in certain situations. However, they miss a descriptive name and when re-reading the code, it can take a while to figure out what they do. That’s why it’s helpful to give long and complex functions a descriptive name. It may be worthwhile to take a look at your own projects or other people’s code to reflect on this part of your coding style.

4. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

Use `is.function()` to test if an object is a function. Consider using `is.primitive()` to test specifically for primitive functions.

```{r}
is.primitive(c)

is.primitive(mean)

is.function(`+`)

is.function(updatefi::get_econ_fi)
```

This code makes a list of all functions in the base package.

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

Use it to answer the following questions:

a. Which base function has the most arguments?

b. How many base functions have no arguments? What’s special about those functions?

c. How could you adapt the code to find all primitive functions?


a. To find the function with the most arguments, we first compute the length of `formals()`.

```{r}
library(purrr)

n_args <- funs |> map(formals) |> map_int(length)

# The full functions should be:
n_args_2 <- funs |> map(\(x){formals(x)}) |> map_int(\(x){length(x)})

# Verify the results:
identical(n_args, n_args_2)
```

Then we sort `n_args` in decreasing order and look at its first entries.

```{r}
n_args |> 
  sort(decreasing = TRUE) |> 
  head(n = 3)
```

b. How many base functions have no arguments? What’s special about those functions?

```{r}
length(n_args[n_args == 0])

# or:

sum(n_args == 0)


sample(n_args[n_args == 0], size = 5)

```

However, this over counts because `formals()` returns `NULL` for primitive functions, and **`length(NULL)` is `0`**. To fix this, we can first remove the primitive functions:

```{r}
n_args_2 <- funs |> 
  discard(is.primitive) |> 
  map(\(x){formals(x)}) |> 
  map_int(\(x){length(x)})

sum(n_args_2 == 0)
```

Indeed, most of the functions with no arguments are actually primitive functions.


c. How could you adapt the code to find all primitive functions?

```{r}
n_args_3 <- Filter(is.primitive, objs)

length(n_args_3)
```


6. What are the three important components of a function?

These components are the function’s `body()`, `formals()` and `environment()`. However, as mentioned in Advanced R:

There is one exception to the rule that functions have three components. Primitive functions, like `sum()`, call C code directly with `.Primitive()` and contain no R code. Therefore, their `formals()`, `body()`, and `environment()` are all `NULL`.


7. When does printing a function not show what environment it was created in?

Primitive functions and functions created in the global environment do not print their environment.

```{r}
c

`!`
```

## Function composition

Base R provides two ways to compose multiple function calls. For example, imagine you want to compute the population standard deviation using `sqrt()` and `mean()` as building blocks:

```{r}
square <- function(x) x^2

deviation <- function(x) x - mean(x)
```

You either nest the function calls:

```{r}
x <- runif(100)

sqrt(mean(square(deviation(x))))
```

Or you save the intermediate results as variables:

```{r}
out <- deviation(x)
out <- square(out)
out <- mean(out)
out <- sqrt(out)
out
```

The magrittr package provides a third option: the binary operator `%>% (|>)`, which is called the pipe and is pronounced as “and then”.

```{r}
library(magrittr)

x %>%
  deviation() %>%
  square() %>%
  mean() %>%
  sqrt()
```

`x %>% f()` is equivalent to` f(x)`; `x %>% f(y)` is equivalent to `f(x, y)`. 

The pipe allows you to **focus on the high-level composition of functions rather than the low-level flow of data**; **the focus is on what’s being done (the verbs), rather than on what’s being modified (the nouns)**.

This style is common in Haskell and F#, the main inspiration for magrittr, and is the default style in stack based programming languages like Forth and Factor.

Each of the three options has its own strengths and weaknesses:

- Nesting, `f(g(x))`, is concise, and well suited for short sequences. But longer sequences are hard to read because they are read inside out and right to left. As a result, arguments can get spread out over long distances creating the **Dagwood sandwich problem**.

- Intermediate objects, `y <- f(x); g(y)`, requires you to name intermediate objects. This is a strength when objects are important, but a weakness when values are truly intermediate.

- Piping, `x %>% f() %>% g()`, allows you to read code in straightforward left-to-right fashion and doesn’t require you to name intermediate objects. But you can only use it with linear sequences of transformations of a single object. It also requires an additional third party package and assumes that the reader understands piping.


Most code will use a combination of all three styles. Piping is more common in data analysis code, as much of an analysis consists of a sequence of transformations of an object (like a data frame or plot). I tend to use piping infrequently in packages; not because it is a bad idea, but because it’s often a less natural fit.


## Lexical scoping

In Chapter 2, we discussed assignment, the act of binding a name to a value. Here we’ll discuss **scoping**, the act of finding the value associated with a name.

The basic rules of scoping are quite intuitive, and you’ve probably already internalised them, even if you never explicitly studied them. For example, what will the following code return, 10 or 20?

```{r}
x <- 10

g01 <- function() {
  x <- 20
  x
}

g01()
```

In this section, you’ll learn the formal rules of scoping as well as some of its more subtle details. A deeper understanding of scoping will help you to use more advanced functional programming tools, and eventually, even to write tools that translate R code into other languages.

R uses **lexical scoping**: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” here is not the English adjective that means relating to words or a vocabulary. It’s a technical CS term that tells us that **the scoping rules use a parse-time, rather than a run-time structure**.

R’s lexical scoping follows four primary rules:

- Name masking
- Functions versus variables
- A fresh start
- Dynamic lookup


## Name masking

The basic principle of lexical scoping is that names defined inside a function mask names defined outside a function. This is illustrated in the following example.

```{r}
x <- 10
y <- 20

g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}

g02()
```

**If a name isn’t defined inside a function, R looks one level up**.

```{r}
x <- 2

g03 <- function() {
  y <- 1
  c(x, y)
}

g03()

```

The same rules apply if a function is **defined inside another function**. First, R looks inside the current function. Then, it looks where that function was defined (and so on, all the way up to the global environment). Finally, it looks in other loaded packages.


Run the following code in your head, then confirm the result by running the code.


```{r}
x <- 1

g04 <- function() {
  
  y <- 2
  
  i <- function() {
    
    z <- 3
    
    c(x, y, z)
    
  }
  
  i()
  
}


g04()

```

The same rules also apply to functions created by other functions, which I call manufactured functions, the topic of Chapter 10.


### Functions versus variables

In R, functions are ordinary objects. This means the scoping rules described above also apply to functions:

```{r}
g07 <- function(x) x + 1

g07(10)



g08 <- function() {
  g07 <- function(x) x + 100
  
  g07(10)
}

g08()
```

However, when a function and a non-function share the same name (they must, of course, reside in different environments), applying these rules gets a little more complicated. When you use a name in a function call, R ignores non-function objects when looking for that value. For example, in the code below, g09 takes on two different values:

```{r}
g09 <- function(x) x + 100

g10 <- function() {
  g09 <- 10
  
  g09(g09)
}


g10()

```

For the record, using the same name for different things is confusing and best avoided!


### A fresh start

What happens to values between invocations of a function? Consider the example below. What will happen the first time you run this function? What will happen the second time? (If you haven’t seen exists() before, it returns TRUE if there’s a variable with that name and returns FALSE if not.)

```{r}
g11 <- function() {
  
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}

g11()
g11()
```

You might be surprised that `g11()` always returns the same value. This happens because **every time a function is called a new environment is created to host its execution**. This means that a function has no way to tell what happened the last time it was run; each invocation is completely independent. We’ll see some ways to get around this in Section 10.2.4.


### Dynamic lookup

Lexical scoping determines where, but not when to look for values. R looks for values when the function is run, not when the function is created. Together, these two properties tell us that **the output of a function can differ depending on the objects outside the function’s environment**:

```{r}
g12 <- function() x + 1

x <- 15

g12()


x <- 20

g12()
```

This behaviour can be quite annoying. If you make a spelling mistake in your code, you won’t get an error message when you create the function. And depending on the variables defined in the global environment, you might not even get an error message when you run the function.

```{r}
codetools::findGlobals(g12)

codetools::findGlobals(updatefi::update_fi)
```

To solve this problem, you can manually change the function’s environment to the emptyenv(), an environment which contains nothing:

```{r}
environment(g12) <- emptyenv()

# g12()
```

The problem and its solution reveal why this seemingly undesirable behaviour exists: R relies on lexical scoping to find everything, from the obvious, like `mean()`, to the less obvious, like `+` or even `{`. This gives R’s scoping rules a rather beautiful simplicity.


### 6.4.5 Exercises

1. What does the following code return? Why? Describe how each of the three c’s is interpreted.

```{r}
c <- 10

c(c = c)
```

This code returns a named numeric vector of length one — with one element of the value 10 and the name "c". The first c represents the c() function, the second c is interpreted as a (quoted) name and the third c as a value.


2. What are the four principles that govern how R looks for values?

R’s lexical scoping rules are based on these four principles:

- Name masking
- Functions vs. variables
- A fresh start
- Dynamic lookup


3. What does the following function return? Make a prediction before running the code yourself.

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}


f(10)
```

Within this nested function two more functions also named f are defined and called. Because the functions are each executed in their own environment R will look up and use the functions defined last in these environments. The innermost `f()` is called last, though it is the first function to return a value. Therefore, the order of the calculation passes “from the inside to the outside” and the function returns `((10 ^ 2) + 1) * 2`, i.e. 202.


## Lazy evaluation

In R, function arguments are **lazily evaluated**: they’re only evaluated if accessed. For example, this code doesn’t generate an error because x is never used:

```{r}
h01 <- function(x) {
  10
}

h01()

h01(stop("This is an error!"))
```

This is an important feature because it allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed.


### Promises

Lazy evaluation is powered by a data structure called a **promise**, or (less commonly) a **thunk**. It’s one of the features that makes R such an interesting programming language (we’ll return to promises again in Section 20.3).

A promise has three components:

- An expression, like `x + y`, which gives rise to the delayed computation.

- An environment where the expression should be evaluated, i.e. the environment where the function is called. This makes sure that the following function returns 11, not 101:

```{r}
y <- 10

h02 <- function(x) {
  y <- 100
  x + 1
}

h02(y)
```

This also means that when you do assignment inside a call to a function, the variable is bound outside of the function, not inside of it.

```{r}
h02(y <- 1000)

y
```

A value, which is computed and cached the first time a promise is accessed when the expression is evaluated in the specified environment. This ensures that the promise is evaluated at most once, and is why you only see “Calculating…” printed once in the following example.

```{r}
double <- function(x) {
  message("Calculating...")
  x * 2
}


double(2)
```

```{r}
h02 <- function(x) {
  c(x, x)
}

h02(double(20))
```

You cannot manipulate promises with R code. Promises are like a quantum state: **any attempt to inspect them with R code will force an immediate evaluation, making the promise disappear**. Later, in Section 20.3, you’ll learn about quosures, which convert promises into an R object where you can easily inspect the expression and the environment.


### Default arguments

Thanks to lazy evaluation, default values can be defined in terms of other arguments, or even in terms of variables defined later in the function:

```{r}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100

  c(x, y, z)
  }

h04()
```

Many base R functions use this technique, but I don’t recommend it. **It makes the code harder to understand**: to predict what will be returned, **you need to know the exact order in which default arguments are evaluated**.

The evaluation environment is slightly different for default and user supplied arguments, as default arguments are evaluated inside the function. This means that seemingly identical calls can yield different results. It’s easiest to see this with an extreme example:

```{r}
h05 <- function(x = ls()) {
  a <- 1
  x
}

# ls() evaluated inside h05:
h05()
#> [1] "a" "x"

# ls() evaluated in global environment:
h05(ls())
#> [1] "h05"
```


## Missing arguments

To determine if an argument’s value comes from the user or from a default, you can use `missing()`:

```{r}
h06 <- function(x = 10) {
  list(missing(x), x)
}

str(h06())

str(h06(10))
```

`missing()` is best used sparingly, however. Take `sample()`, for example. How many arguments are required?

```{r}
args(sample)
```

### 6.5.4 Exercises

What important property of `&&` makes `x_ok()` work?

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
#> [1] FALSE
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE
```

What is different with this code? Why is this behaviour undesirable here?

```{r}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
#> logical(0)
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE FALSE FALSE
```

In summary: `&&` short-circuits which means that if the left-hand side is `FALSE` it doesn’t evaluate the right-hand side (because it doesn’t matter). Similarly, if the left-hand side of `||` is TRUE it doesn’t evaluate the right-hand side.

We expect `x_ok()` to validate its input via certain criteria: it must not be `NULL`, have length 1 and be greater than 0. Meaningful outcomes for this assertion will be `TRUE`, `FALSE` or `NA`. The desired behaviour is reached by combining the assertions through `&&` instead of `&`.

`&&` does not perform elementwise comparisons; instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation “proceeds only until the result is determined” (from `?Logic`). This means that the RHS of `&&` won’t be evaluated if the LHS already determines the outcome of the comparison (e.g. evaluate to `FALSE`). This behaviour is also known as “short-circuiting.” For some situations (`x = 1`) both operators will lead to the same result. But this is not always the case. For `x = NULL`, the `&&`-operator will stop after the `!is.null` statement and return the result. The following conditions won’t even be evaluated! (If the other conditions are also evaluated (by the use of `&`), the outcome would change. `NULL > 0` returns `logical(0)`, which is not helpful in this case.)

We can also see the difference in behaviour, when we set `x = 1:3`. The &&-operator returns the result from `length(x) == 1`, which is `FALSE`. Using & as the logical operator leads to the (vectorised) `x > 0` condition being evaluated and also returned.


2. What does this function return? Why? Which principle does it illustrate?

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}

f2()
```

The function returns 100. The default argument (`x = z`) gets lazily evaluated within the function environment when `x` gets accessed. At this time `z` has already been bound to the value `100`. The illustrated principle here is lazy evaluation.


3. **What does this function return? Why? Which principle does it illustrate?**

```{r}
y <- 10

f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}


f1()

y
```

The function returns `c(2, 1)` which is due to name masking. When `x` is accessed within `c()`, the promise `x = {y <- 1; 2}` is evaluated inside `f1()`’s environment. `y` gets bound to the value 1 and the return value of `{()` `(2)` gets assigned to `x`. When y gets accessed next within `c()`, it has already the value `1` and R doesn’t need to look it up any further. Therefore, the promise `y = 0` won’t be evaluated. Also, as `y` is assigned within `f1()`’s environment, the value of the global variable `y` is left untouched.


4. In `hist()`, the default value of xlim is range(breaks), the default value for breaks is "Sturges", and

```{r}
range("Sturges")
#> [1] "Sturges" "Sturges"
```

The `xlim` argument of `hist()` defines the range of the histogram’s x-axis. In order to provide a valid axis `xlim` must contain a numeric vector of exactly two unique values. Consequently, for the default `xlim = range(breaks)`), `breaks` must evaluate to a vector with at least two unique values.

During execution `hist()` overwrites the `breaks` argument. The `breaks` argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore, the specific behaviour depends highly on the input. But `hist` ensures that `breaks` evaluates to a numeric vector containing at least two unique elements before `xlim` is computed.


5. **Explain why this function works. Why is it confusing**?


```{r}
show_time <- function(x = stop("Error!")) {
  
  stop <- function(...) Sys.time()
  
  print(x)
}

show_time()

```

Before `show_time()` accesses `x` (default `stop("Error")`), the `stop()` function is masked by `function(...) Sys.time()`. As default arguments are evaluated in the function environment, `print(x)` will be evaluated as `print(Sys.time())`.

This function is confusing because its behaviour changes when `x`’s value is supplied directly. Now the value from the calling environment will be used and the overwriting of `stop()` won’t affect x anymore.

```{r}
# show_time(x = stop("Error!"))
```


6. How many arguments are required when calling `library()`?

`library()` doesn’t require any arguments. When called without arguments `library()` invisibly returns a list of class `libraryIQR`, which contains a results matrix with one row and three columns per installed package. These columns contain entries for the name of the package (“Package”), the path to the package (“LibPath”) and the title of the package (“Title”). `library()` also has its own print method (`print.libraryIQR()`), which displays this information conveniently in its own window.


## `...` (dot-dot-dot)

Functions can have a special argument `...` (pronounced dot-dot-dot). With it, a function can take any number of additional arguments. In other programming languages, this type of argument is often called varargs (short for variable arguments), and a function that uses it is said to be variadic.

You can also use `...` to pass those additional arguments on to another function.

```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) {
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
```

Using a special form, `..N`, it’s possible (but rarely useful) to refer to elements of `...` by position:

```{r}
i03 <- function(...) {
  list(first = ..1, third = ..3)
}

str(i03(1, 2, 3))
```

More useful is `list(...)`, which evaluates the arguments and stores them in a list:

```{r}
i04 <- function(...) {
  list(...)
}

str(i04(a = 1, b = 2))
```

(See also `rlang::list2()` to support splicing and to silently ignore trailing commas, and `rlang::enquos()` to capture unevaluated arguments, the topic of quasiquotation.)

There are two primary uses of `...`, both of which we’ll come back to later in the book:


- If your function takes a function as an argument, you want some way to pass additional arguments to that function. In this example, `lapply()` uses `...` to pass `na.rm` on to `mean()`:

```{r}
x <- list(c(1, 3, NA), c(4, NA, 6))

str(lapply(x, mean, na.rm = TRUE))
```

- If your function is an S3 generic, you need some way to allow methods to take arbitrary extra arguments. For example, take the `print()` function. Because there are different options for printing depending on the type of object, there’s no way to pre-specify every possible argument and ... allows individual methods to have different arguments:

```{r}
print(factor(letters), max.levels = 4)

print(y ~ x, showEnv = TRUE)
```

Using `...` comes with two downsides:

- When you use it to pass arguments to another function, you have to carefully explain to the user where those arguments go. This makes it hard to understand what you can do with functions like lapply() and plot().

- A misspelled argument will not raise an error. This makes it easy for typos to go unnoticed:

```{r}
sum(1, 2, NA, na_rm = TRUE)
```


### 6.6.1 Exercises

Explain the following results:

```{r}
sum(1, 2, 3)
#> [1] 6
mean(1, 2, 3)
#> [1] 1

sum(1, 2, 3, na.omit = TRUE)
#> [1] 7
mean(1, 2, 3, na.omit = TRUE)
#> [1] 1
```

Let’s inspect the arguments and their order for both functions. For `sum()` these are `...` and `na.rm`:

```{r}
str(sum)
#> function (..., na.rm = FALSE)
```

For the `...` argument `sum()` expects numeric, complex, or logical vector input (see `?sum`). Unfortunately, when `...` is used, misspelled arguments (!) like `na.omit` won’t raise an error (in case of no further input checks). So instead, `na.omit` is treated as a logical and becomes part of the `...` argument. It will be coerced to `1` and be part of the `sum`. All other arguments are left unchanged. Therefore `sum(1, 2, 3)` returns `6` and `sum(1, 2, 3, na.omit = TRUE)` returns `7`.

In contrast, the generic function `mean()` expects `x`, `trim`, `na.rm` and `...` for its default method.

```{r}
str(mean.default)
#> function (x, trim = 0, na.rm = FALSE, ...)
```

As `na.omit` is not one of `mean()`’s named arguments (`x`; and no candidate for partial matching), `na.omit` again becomes part of the `...` argument. However, in contrast to `sum()` the elements of `...` are not “part” of the mean. 

The other supplied arguments are matched by their order, i.e. `x = 1`, `trim = 2` and `na.rm = 3`. As `x` is of length `1` and not `NA`, the settings of `trim` and `na.rm` do not affect the calculation of the mean. Both calls (`mean(1, 2, 3)` and `mean(1, 2, 3, na.omit = TRUE)`) return 1.


2. Explain how to find the documentation for the named arguments in the following function call:

```{r}
plot(1:10, col = "red", pch = 20, xlab = "x", col.lab = "blue")
```


First we type `?plot` in the console and check the “Usage” section which contains:

```{r}
# plot(x, y, ...)
```

The arguments we want to learn more about (`col`, `pch`, `xlab`, `col.lab`) are part of the `...` argument. There we can find information for the `xlab` argument and a recommendation to visit `?par` for the other arguments. Under `?par` we type “col” into the search bar, which leads us to the section “Color Specification.” We also search for the `pch` argument, which leads to the recommendation to check `?points`. Finally, `col.lab` is also directly documented within `?par`.


## Exiting a function

Most functions exit in one of two ways: they either return a value, indicating success, or they throw an error, indicating failure. This section describes return values (implicit versus explicit; visible versus invisible), briefly discusses errors, and introduces exit handlers, which allow you to run code when a function exits.


### Implicit versus explicit returns

There are two ways that a function can return a value:

- Implicitly, where the last evaluated expression is the return value:

```{r}
j01 <- function(x) {
  if (x < 10) {
    0
  } else {
    10
  }
}

j01(5)

j01(15)
```


- Explicitly, by calling return():

```{r}
j02 <- function(x) {
  if (x < 10) {
    return(0)
  } else {
    return(10)
  }
}

j02(15)
```


### Invisible values

Most functions return visibly: calling the function in an interactive context prints the result.

```{r}
j03 <- function() 1

j03()
```

However, you can prevent automatic printing by applying `invisible()` to the last value:

```{r}
j04 <- function() invisible(1)

j04()
```


To verify that this value does indeed exist, you can explicitly print it or wrap it in parentheses:

```{r}
print(j04())

# or 

(j04())
```

Alternatively, you can use `withVisible()` to return the value and a visibility flag:

```{r}
str(withVisible(j04()))
```

The most common function that returns invisibly is `<-`:

```{r}
a <- 2

(a <- 2)
```

This is what makes it possible to chain assignments:

```{r}
a <- b <- c <- d <- 2
```

In general, any function called primarily for a side effect (like `<-`, `print()`, or `plot()`) should return an invisible value (typically the value of the first argument).


### Errors

If a function cannot complete its assigned task, it should throw an error with `stop()`, which immediately terminates the execution of the function.

```{r}
j05 <- function() {
  stop("Error.")
  return(10)
}

# j05()
```

An error indicates that something has gone wrong, and forces the user to deal with the problem. Some languages (like C, Go, and Rust) rely on special return values to indicate problems, but in R you should always throw an error. You’ll learn more about errors, and how to handle them, in Chapter 8.


### Exit handlers

Sometimes a function needs to make temporary changes to the global state. But having to cleanup those changes can be painful (what happens if there’s an error?). 

To ensure that these changes are undone and that the global state is restored no matter how a function exits, use `on.exit()` to set up an **exit handler**.

The following simple example shows that the exit handler is run regardless of whether the function exits normally or with an error.

```{r}
j06 <- function(x) {
  cat("Hello\n")
  on.exit(cat("Goodbye!\n"), add = TRUE)
  
  if (x) {
    return(10)
  } else {
    stop("Error")
  }
}


j06(TRUE)
# j06(FALSE)
```

Always set `add = TRUE` when using `on.exit()`. If you don’t, each call to `on.exit()` will overwrite the previous exit handler. Even when only registering a single handler, it’s good practice to set `add = TRUE` so that you won’t get any unpleasant surprises if you later add more exit handlers.

`on.exit()` is useful because it allows you to place clean-up code directly next to the code that requires clean-up:


The withr package provides a collection of other functions for setting up a temporary state.


In R 3.4 and earlier, `on.exit()` expressions are always run in order of creation:

```{r}
j08 <- function() {
  on.exit(message("Yang"), add = TRUE)
  on.exit(message("Lara"), add = TRUE)
}

j08()
```

This can make cleanup a little tricky if some actions need to happen in a specific order; typically you want the most recent added expression to be run first. In R 3.5 and later, you can control this by setting `after = FALSE`:

```{r}
j09 <- function() {
  on.exit(message("Yang"), add = TRUE, after = FALSE)
  on.exit(message("Lara"), add = TRUE, after = FALSE)
}

j09()
```


### 6.7.5 Exercises

1. What does `load()` return? Why don’t you normally see these values?

`load()` loads objects saved to disk in `.Rdata` files by `save()`. When run successfully, `load()` invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument verbose to `TRUE` or surround the call in parentheses to trigger R’s auto-printing mechanism.


2. What does `write.table()` return? What would be more useful?

`write.table()` writes an object, usually a data frame or a matrix, to disk. The function invisibly returns `NULL`. It would be more useful if `write.table()` would (invisibly) return the input data, `x`. This would allow to save intermediate results and directly take on further processing steps without breaking the flow of the code (i.e. breaking it into different lines). One package which uses this pattern is the {readr} package, which is part of the tidyverse-ecosystem.


3. (skipped)


4. Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).

To control the graphics device we use `pdf()` and `dev.off()`. To ensure a clean termination `on.exit()` is used.

```{r}
plot_pdf <- function(code) {
  pdf("test.pdf")
  on.exit(dev.off(), add = TRUE)
}
```


## Function forms

> To understand computations in R, two slogans are helpful:
> 
> - Everything that exists is an object.
> - Everything that happens is a function call.    
> — John Chambers


While everything that happens in R is a result of a function call, not all calls look the same. Function calls come in four varieties:

- **prefix**: the function name comes before its arguments, like `foofy(a, b, c)`. These constitute of the majority of function calls in R.

- **infix**: the function name comes in between its arguments, like `x + y`. Infix forms are used for many mathematical operators, and for user-defined functions that begin and end with `%`.

- **replacement**: functions that replace values by assignment, like `names(df) <- c("a", "b", "c")`. They actually look like prefix functions.

- **special**: functions like `[[`, `if`, and `for`. While they don’t have a consistent structure, they play important roles in R’s syntax.


While there are four forms, you actually only need one because any call can be written in prefix form. I’ll demonstrate this property, and then you’ll learn about each of the forms in turn.

```{r}
# Prefix form:
`<-`(a, 2)

# Infix form:
a <- 2
```


### Rewriting to prefix form

An interesting property of R is that every infix, replacement, or special form can be rewritten in prefix form. Doing so is useful because it helps you better understand the structure of the language, it gives you the real name of every function, and it allows you to modify those functions for fun and profit.

The following example shows three pairs of equivalent calls, rewriting an infix form, replacement form, and a special form into prefix form.

```{r}
1 + 2

`+`(1, 2)
```

```{r}

df <- data.frame("a" = 1, "b" = 2, "c" = 3)

names(df)

names(df) <- c("x", "y", "z")

`names<-`(df, c("Lara", "Eric", "Yang"))
```

```{r}
for (i in 1:10) {print(i)}

`for`(i, 1:10, print(i))
```

Suprisingly, in R, `for` can be called like a regular function! The same is true for basically every operation in R, which means that knowing the function name of a non-prefix function allows you to override its behaviour. 

A more useful application comes up when using functional programming tools. For example, you could use `lapply()` to add 3 to every element of a list by first defining a function `add()`:

```{r}
add <- function(x, y) x + y

lapply(list(1:3, 4:5), add, 3)
```

But we can also get the same result simply by relying on the existing `+` function:

```{r}
lapply(list(1:3, 4:5), `+`, 3)
```

### Prefix form

The prefix form is the most common form in R code, and indeed in the majority of programming languages. Prefix calls in R are a little special because you can specify arguments in three ways:

- By position, like `help(mean)`.
- Using partial matching, like `help(top = mean)`.
- By name, like `help(topic = mean)`.


As illustrated by the following chunk, arguments are matched by exact name, then with unique prefixes, and finally by position.

```{r}
k01 <- function(para1, para2, para3) {
  list(a1 = para1, b2 = para2, c3 = para3)
}

str(k01(1, 2, 3))

str(k01(para3 = 3, 1, 2))

str(k01(para3 = 1, para2 = 2, para1 = 3))
```

In general, use positional matching only for the first one or two arguments; they will be the most commonly used, and most readers will know what they are. Avoid using positional matching for less commonly used arguments, and never use partial matching.

Unfortunately you can’t disable partial matching, but you can turn it into a warning with the `warnPartialMatchArgs` option:

```{r}
options(warnPartialMatchArgs = TRUE)
# x <- k01(a = 1, 2, 3)
```


### Infix functions

Infix functions get their name from the fact the function name comes inbetween its arguments, and hence have two arguments. 

R comes with a number of built-in infix operators: `:`, `::`, `:::`, `$`, `@`, `^`, `*`, `/`, `+`, `-`, `>`, `>=`, `<`, `<=`, `==`, `!=`, `!`, `&`, `&&`, `|`, `||`, `~`, `<-`, and `<<-`. 

You can also create your own infix functions that start and end with `%`. Base R uses this pattern to define `%%`, `%*%`, `%/%`, `%in%`, `%o%`, and `%x%`.

Defining your own infix function is simple. You create a two argument function and bind it to a name that starts and ends with `%`:

```{r}
`%eric%` <- function(a, b) paste0(a, b)

"Eric" %eric% "!"
```

The names of infix functions are more flexible than regular R functions: they can contain any sequence of characters except for `%`. You will need to escape any special characters in the string used to define the function, but not when you call it.

R’s default precedence rules mean that infix operators are composed left to right.

There are two special infix functions that can be called with a single argument: `+` and `-`.

```{r}
1

-1

+1
```


### Replacement functions

Replacement functions act like they modify their arguments in place, and have the special name `xxx<-`. They must have arguments named `x` and `value`, and must return the modified object. For example, the following function modifies the second element of a vector:

```{r}
`second<-` <- function(x, value) {
  x[2] <- value
  x
}

x <- 1:10
second(x) <- 5L
x
```


### Special forms

Finally, there are a bunch of language features that are usually written in special ways, but also have prefix forms. These include parentheses:

- `(x)` (``(`(x)`)
- {x} (``{`(x)`).


The subsetting operators:

- `x[i]` (``[`(x, i)`)
- `x[[i]]` (``[[`(x, i)`)

And the tools of control flow:

`if (cond) true` (``if`(cond, true)`)
`if (cond) true else false` (``if`(cond, true, false)`)

`for(var in seq) action` (``for`(var, seq, action)`)
`while(cond) action` (``while`(cond, action)`)

`repeat expr` (``repeat`(expr)`)
`next` (``next`()`)
`break` (``break`()`)


Finally, **the most complex is the `function` function**:

`function(arg1, arg2) {body}`

(``function`(alist(arg1, arg2), body, env)`)

Knowing the name of the function that underlies a special form is useful for getting documentation: `?(` is a syntax error; ?`(` will give you the documentation for parentheses.

All special forms are implemented as primitive functions (i.e. in C); this means printing these functions is not informative:

```{r}
`for`
```


### 6.8.6 Exercises

1. Rewrite the following code snippets into prefix form:

```{r}
1 + 2 + 3

`+`(`+`(1, 2), 3)

```

```{r}
1 + (2 + 3)

`+`(1, `+`(2, 3))
```


```{r}
if (length(x) <= 5) x[[5]] else x[[4]]
```

(skip the rest questions)
